/*
Tengo Language
Checks that numbered callouts (<\d+>) are not missing from outside the listing block 
$ tengo MatchingNumberedCallouts.tengo <asciidoc_file_to_validate>
*/

fmt := import("fmt")
os := import("os")
text := import("text")

input := os.args()
scope := os.read_file(input[2])
matches := []

//trim extra whitespace
scope = text.trim_space(scope)
//add a newline, it might be missing
scope += "\n"

codeblock_callout_regex := ".+(<\\d+>)+"
callout_regex := "^<(\\d+)>"
codeblock_callouts := []
callouts := []
errors:= []
inside := false

num_lines := len(text.split(scope, "\n"))

for line in text.split(scope, "\n") {
  if text.re_match(codeblock_callout_regex, line) {
    inside = true
    //account for lines with multiple callouts
    for i := 1; i < num_lines; i++ {
      //text.contains must be str, not regex
      str := "<" + i + ">"
      if text.contains(line, str) {
        codeblock_callouts = append(codeblock_callouts, i)
      }
    }
  }

  if text.re_match(callout_regex, line) {
    inside = false
    for i := 1; i < len(codeblock_callouts); i++ {
      str := "<" + i + ">"
      //if a match is not found, raise an error
      if !text.contains(line, str) {
        fmt.println(i)
        // add all matches
/*        start := text.index(scope, line)
        matches = append(matches, {begin: start, end: start + len(line)})*/
      }
    }
  }
}

if len(codeblock_callouts) > 0 && inside == false {
  codeblock_callouts = []
}

if len(matches) == 0 {  
  fmt.println("Numbered callouts are balanced")
} else {
  fmt.println(matches) 
}
