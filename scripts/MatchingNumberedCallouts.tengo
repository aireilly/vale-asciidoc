/*
Tengo Language
Checks that numbered callouts (<\d+>) are matching 
$ tengo MatchingNumberedCallouts.tengo <asciidoc_file_to_validate>
*/

fmt := import("fmt")
os := import("os")
text := import("text")

input := os.args()
scope := os.read_file(input[2])
matches := []

//trim extra whitespace
scope = text.trim_space(scope)
//add a newline, it might be missing
scope += "\n"

codeblock_callout_regex := ".+(<\\d+>)+"
callout_regex := "^<(\\d+)>"
codeblock_callouts := []
inside := false

num_lines := len(text.split(scope, "\n"))

for line in text.split(scope, "\n") {
  if text.re_match(codeblock_callout_regex, line) {
    inside = true
    //account for lines with multiple callouts
    for i := 1; i < num_lines; i++ {
      //text.contains must be str, not regex
      str := "<" + i + ">"
      if text.contains(line, str) {
        codeblock_callouts = append(codeblock_callouts, i)
      }
    }
  }

  if text.re_match(callout_regex, line) {
    inside = false
    start := text.index(scope, line)
    matches = append(matches, {begin: start, end: start + len(line)})
    for i in codeblock_callouts {
      //cast int > string
      j := text.itoa(i)
      str := "<" + j + ">"
      if text.contains(line, str) {
        if len(matches) > 0 {
          //remove the most recently added match
          matches = matches[:len(matches)-1]
        }
      }
    }
  } else if len(codeblock_callouts) > 0 && inside == false {
    codeblock_callouts = []
  }
}

if len(matches) == 0 {  
  fmt.println("Numbered callouts are balanced")
} else {
  fmt.println(matches) 
}
